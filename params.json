{
  "name": "Docker-dropwizard-example",
  "tagline": "Example docker image which runs a dropwizard application, extending to report to add StatsDReporter",
  "body": "# Docker Dropwizard image\r\n\r\nExample Docker image for running a Dropwizard Application in a container.\r\n\r\nRequires:\r\n* [Docker](https://www.docker.com/)\r\n* [Boot2Docker](http://boot2docker.io/)\r\n* JDK (to compile java file locally)\r\n* [Gradle](https://gradle.org/) (for build automation)\r\n\r\nTo run locally:\r\n\r\n```\r\ngradle run\r\n# ./go\r\n```\r\n\r\nTo build docker image:\r\n\r\n```\r\ngradle dockerBuildImage\r\n# ./dockerBuildImage.sh (requires oneJar task to build dropwizard application)\r\n```\r\n\r\nTo run docker image:\r\n\r\n```\r\ngradle dockerRunImage\r\n./dockerRunImage.sh (requires built image)\r\n```\r\n\r\nWhen image is running use `boot2docker ip` to get the docker IP and `docker ps` to see the port assigned to the container port 8080, then curl `http://<dockerip>:<port>/hello` to call the dropwizard application running in the container.\r\n\r\nIf using LINUX you can use localhost and have to `sudo` docker commands.\r\n\r\n## Details\r\n\r\nThis is a bare bones example for building an image for running a single Dropwizard application. It uses the standard docker java:jre-8 image as base, copies necessary files into image into folder `/opt/dropwizard` and runs command to start dropwizard application.\r\n\r\nDockerfile:\r\n\r\n```\r\nFROM java:8-jre\r\nCOPY config.yml /opt/dropwizard/\r\nCOPY build/libs/docker-dropwizard-application-standalone.jar /opt/dropwizard/\r\nEXPOSE 8080\r\nWORKDIR /opt/dropwizard\r\nCMD [\"java\", \"-jar\", \"-Done-jar.silent=true\", \"docker-dropwizard-application-standalone.jar\", \"server\", \"config.yml\"]\r\n```\r\n\r\n## Conclusions\r\n\r\nThis is a simple way of defining a disposal container for a dropwizard application, taking effort away from operations and making the development team responsible for how their application will be hosted and run. Your application will be completely isolated from other parts of your solution running on the same host machine, including other instances of the same application for scaling and redundancy.\r\n\r\nInstead of thinking of instances of your application, you have instances of your container image, hosted on one or more docker hosts depending on your architecture. Used correctly, you can create container instances as needed, kill when done, using versioning of images to release new versions of the service.\r\n\r\nThings to consider:\r\n* How to extract information from running container instance application (logging, performance monitoring etc.)\r\n* Port management, how to create new containers with dynamic port allocation (to avoid collisions) while still balancing load between them\r\n* General release management using Docker\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}